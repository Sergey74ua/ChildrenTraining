/*
 *ДЗ_1: Исходный код программы начинается с директив подключения библиотеки,
 *		включения ее имен в глобальное пространство, объявления глобальных
 *		переменных и константы. А именно:
 *			1. Двумерный массив чисел 100 * 100 минного поля;
 *			2. Еще один двумерный массив чисел 100 * 100 отображаемой карты;
 *			3. И три числовых константы, размера карты и количества мин.
 *		Далее, исполнение программы переходит к функции Main, см. метку ДЗ_2.
 */

//у нас будет поле 9х9 клеток (задаем 10х10, что бы еще вписать нумерацию)
//будет 10 бомб (звездочек)

#include <iostream>
using namespace std;
int field[100][100];
// -1 - mine
// 0-8 - cell
int field_p[100][100];
// -2 - closed
// -1  - flag
// 0-8  - opened
const int N = 9, M = 9, K = 10;


/*
 *ДЗ_3: Функция print_field очищает экран и запускает два цикла:
 *			1. Выводит строку с нумерацией колонок, с проверкой счетчика для пробела;
 *			2. Двойной цикл печатает карту, с проверкой счетчика для пробела и проверкой
 *			   ячеек двумерного массива карты: закрыта, флажек, мина или счетчик мин.
 */

void print_field()
{
	system("cls");
	cout << "  ";
	for (int i = 0; i < M; ++i)
	{
		cout << " " << i + 1;
		if (i + 1 < 10) cout << ' ';
	}
	cout << endl;
	for (int i = 0; i < N; i++)
	{

		cout << i + 1 << " ";
		if (i + 1 < 10) cout << ' ';

		for (int j = 0; j < M; j++) {
			if (field_p[i][j] == -2) cout << "_  ";
			else if (field_p[i][j] == -1) cout << "f  ";
			else if (field_p[i][j] == -3) cout << "*  ";
			else cout << field_p[i][j] << "  ";
		}
		cout << endl;
	}
	cout << endl << endl << endl;
}


/*
 *ДЗ_5: Функция dfs принимает координаты, проверяет их на принадлежность карте и закрытость,
 *		что не имеет смысла при первичном внешнем вызове, толко при рекурсивном.
 *		Затем окрывает текущую ячейку, перенося в нее значение из массива минной карты.
 *		Далее эта ячейка проверяется на пустоту, но уже на минном поле и в случае наличия
 *		в ней ненулевого счетчика соседних мин, срабатывает первый return, который рекурсивно
 *		будет перезапускать свою же функцию, а не выходить из нее, как обычно принято.
 *		Следом работает двойной цикл, обходящий соседние клетки с исключением самой текущей
 *		ячейки. В теле цикла проверяется условие, целью которого является запуск рекурсии,
 *		но уже с новыми координатами, полученными в ходе обхода соседних ячеек. Неисполение
 *		условия, во-первых предотвращает зацикливание самой функции, а во-вторых, после перебора
 *		всех вариантов и выполнения цикла без выполения условия, выйдет из функции.
 *		Это не только самый сложный для понимания элемент программы, но еще и самый тормозящий
 *		процессор, так как многократно проверяет одни и те же координаты.
 */

void dfs(int x, int y) {
	if (x < 0 || x >= N || y < 0 || y >= M || field_p[x][y] > -2) return;
	field_p[x][y] = field[x][y];
	if (field[x][y] > 0) return;
	for (int i2 = x - 1; i2 <= x + 1; ++i2) {
		for (int j2 = y - 1; j2 <= y + 1; ++j2) {
			if (i2 != x || j2 != y) dfs(i2, j2);
		}
	}
}


/*
 *ДЗ_4: Функция open_cell принимает координаты, проверяет их на наличие мины, возвращая
 *		конец игры. Затем проверяет значение ячейки и в случае наличия мин по соседству
 *		переносит значение счетчика в массив отображаемой карты. В заключении вызывается
 *		функция dfs (см. ДЗ_5), раскрывающая соприкасающиеся пустые ячейки.
 */

// истина - не взорвались на бомбе
//задаем тип boolean, так как у нас условия зависят от того, правда это или нет
//часть кода с bool будет определять, сколько бомб находится вокруг открытой клетки
//смотрим, не взорв.
bool open_cell(int x, int y)
{
	if (field[x][y] == -1) return false;
	if (field[x][y] > 0) {
		field_p[x][y] = field[x][y];
		return true;
	}
	dfs(x, y);
}

/*
 *ДЗ_6: Функция is_win обходит двойным циклом отображаемую карту и суммирует все открытые
 *		ячейки. В итоге возвращает равенство значения счетчика с числом открытых ячеек.
 */

//смотрим: случай выигрыша
bool is_win() {
	int opened = 0;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			if (field_p[i][j] >= 0) opened++; //0 1 2 3
		}
	}
	return (N * M - K == opened); //9*9-10
}

/*
 *ДЗ_7: Функция end_game принимает логическое значение c false по-умолчанию. Двойным циклом
 *		координаты обоих двумерных массивов. Закрытые ячейки открываются, мины переносятся
 *		на отображаемую карту. После чего вызывается функция print_field (см. ДЗ_3) для
 *		отрисовки игровой карты.
 */

//сучай проигрыша (бум-бум)
void end_game(bool is_win = false)
{
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			if (field_p[i][j] == -1) field_p[i][j] = -2;
			if (field[i][j] == -1) field_p[i][j] = -3;
		}
	}
	print_field();
	//в зависимости от результата у нас на экране появится надпись
	cout << "You " << (is_win ? "win" : "lost") << ",\nwanna start new game?:\n";
	string s;
	cin >> s;
}
//1сл - мы взорвались
//2сл - мы живы и закончились клетки
//3сл - мы играли мы играли и случайно на мину упали


/*
 *ДЗ_2: Функция Main является точкой входа, с которой начинается выполнение кода программы.
 *		Функция запускает бесконечный цикл, который можно разделить на два блока:
 *			1. Инициализация новой игры.
 *				1.1. Подвязываем к таймеру генератор случайных чисел для размещения мин;
 *				1.2. Двойной цикл с заполнением двух двумерных массивов значениями 0 и -2,
 *					 но не полностью 100 * 100, а в размерах поля по константам 9 * 9;
 *				1.3. Двойной цикл, один из которых обходит количество мин, а второй бесконечно
 *					 генерирует рандомные координаты с проверкой на совпадение с координатами
 *					 ранее установленных мин;
 * 				1.4. Два двойных цикла, первая пара которых обходит по координатам карту мин и
 *					 ищет пустые клетки, а вторая пара циклов обходит соседние клетки и суммирует
 *					 окружающие мины, исключая выход координат за край карты.
 *			2. Бесконечный цикл хода игры.
 *				2.1. Вызываем функцию print_field для отрисовки сигрового поля (см. ДЗ_3);
 *				2.2. Выводим запрос для ввода команды и координат;
 *				2.3. Инициализируем строковую переменную и принимаем ее значение с консоли;
 *				2.4. Запускаем логический блок, выбирая один из 4 вариантов:
 *					 2.4.1 "\o" - Инициализируем, получаем и смещаем координаты карты, проверяем
 *								  выход за границы карты, функцией !open_cell проверяем на конец
 *								  игры попаданием на мину (см. ДЗ_4) и функцией is_win проверяем
 *								  окончание игры победой (см. ДЗ_6);
 *					 2.4.2 "\f" - Инициализируем, получаем и смещаем координаты карты, проверяем
 *								  выход за границы карты и меняем значение флажка;
 *					 2.4.2 "\n" - прерывание цикла игры и возврат к началу новой игры;
 *					 2.4.2 "\q" - выход из программы.
 */

int main()
{
	while (true) //если мы пока не наступили на бомбу и открыли хорошую клетку, то выполняем следующие условия
	{
		srand(time(0)); //расстановка бомб будет менять 
		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++) {
				field[i][j] = 0;
				field_p[i][j] = -2;
			}
		}
		for (int i = 0; i < K; ++i) { //кол-во бомб
			while (true) {
				int x = rand() % N; //рандомное значение
				int y = rand() % M;
				if (field[x][y] != -1)
				{
					field[x][y] = -1;
					break;
				}
			}
		}
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < M; j++) {
				if (field[i][j] != -1) {
					field[i][j] = 0;
					for (int i2 = i - 1; i2 <= i + 1; ++i2) {
						for (int j2 = j - 1; j2 <= j + 1; ++j2) {
							if (i2 >= 0 && i2 < N && j2 >= 0 && j2 <= M &&
								field[i2][j2] == -1) ++field[i][j];
						}
					}
				}
			}
		}
		while (true) {
			print_field();
			cout << "Enter comand:";
			/*
			\o x y
			\f x y
			\n
			\q
			*/
			string comand;
			cin >> comand;
			if (comand == "\\o") {
				// при указании команды "открыть" задаем возможность выбора координат, т.е. клеточки, которую
				//хотим открыть 
				int x, y;
				cin >> x >> y;
				--x; --y;
				// открываем клетки
				if (x < 0 || x >= N || y < 0 || y >= M || field_p[x][y] >= 0) continue;
				if (!open_cell(x, y)) {
					end_game();
					break;
				}
				if (is_win()) {
					end_game(true);
					break;
				}
			}
			else if (comand == "\\f") {
				// вводим координаты
				int x, y;
				cin >> x >> y;
				--x; --y;
				if (x < 0 || x >= N || y < 0 || y >= M || field_p[x][y] >= 0) continue;
				// ставим флажок
				if (field_p[x][y] == -1) field_p[x][y] = -2;
				else field_p[x][y] = -1;
			}
			else if (comand == "\\n") {
				break;
			}
			else if (comand == "\\q") {
				return 0;
			}
		}
	}
}

//задаем поле
//долго и мучительно рассматриваем все возможные варианты, что может быть в клетке:
//условие "мы еще живы" - правда -- то мы с вами шагаем дальше и играем дальше
//условие "мы нарвались на бомбу" -- то игра заканчивается и на поле показывают расположение всех бомб
//цикла - бегает по всем клеткам свободным, смотрит что туда можно вставить 
//будут расставляться значения, сколько бомб в области клетки
//пока мы с вами еще живы, у нас игра идет и каждый наш шаг, круг цикла продолжается